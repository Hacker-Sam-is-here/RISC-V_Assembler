# RISC-V Simulator Implementation

This document explains the line-by-line implementation of the RISC-V simulator that executes binary code generated by the assembler.

## Memory Layout

The simulator implements a simplified memory model:
- Program Memory: 256 bytes (64 locations)
- Data Memory: 128 bytes (32 locations)
- Stack Memory: 128 bytes (32 locations, grows downward)

## Class Overview

```python
class Simulator:
```
The main class that handles the execution of RISC-V binary instructions.

## Class Initialization

```python
def __init__(self, program):
```
- program: List of 32-bit integer instructions
- Initializes:
  - 32 registers (x0-x31), all set to 0
  - Program counter (pc) starting at 0
  - Data memory array (32 words)
  - Stack memory array (32 words)
  - Halted flag for program termination

## Helper Methods

### Sign Extension
```python
def sign_extend(self, value, bits):
```
- Extends the sign bit for immediate values
- Parameters:
  - value: Number to sign extend
  - bits: Bit width of original value
- Returns sign-extended value

### State Printing
```python
def print_state(self, instr, opcode_name):
```
Prints execution state after each instruction:
- Current PC value
- Executed instruction (hex)
- Register contents
- Data memory contents

## Main Execution Process

### The Run Method
```python
def run(self):
```
Main execution loop that:
1. Fetches instruction at current PC
2. Decodes opcode
3. Executes instruction
4. Updates system state
5. Prints execution trace

### Instruction Execution

#### 1. R-Type Instructions
```python
if opcode == 1:  # add
elif opcode == 2:  # sub
elif opcode == 3:  # slt
elif opcode == 4:  # srl
elif opcode == 5:  # or
elif opcode == 6:  # and
```
- Format: `opcode rd, rs1, rs2`
- Fields:
  - rd: Destination register (bits 16-23)
  - rs1: First source register (bits 8-15)
  - rs2: Second source register (bits 0-7)
- Operations:
  - add: `rd = rs1 + rs2`
  - sub: `rd = rs1 - rs2`
  - slt: `rd = 1 if rs1 < rs2 else 0`
  - srl: `rd = rs1 >>> rs2`
  - or: `rd = rs1 | rs2`
  - and: `rd = rs1 & rs2`

#### 2. I-Type Instructions
```python
elif opcode == 7:  # lw
elif opcode == 8:  # addi
elif opcode == 9:  # jalr
```
- Format: `opcode rd, rs1, imm`
- Fields:
  - rd: Destination register (bits 16-23)
  - rs1: Source register (bits 8-15)
  - imm: Immediate value (bits 0-7)
- Operations:
  - lw: `rd = memory[rs1 + imm]`
  - addi: `rd = rs1 + imm`
  - jalr: `rd = pc + 4; pc = rs1 + imm`

#### 3. S-Type Instructions
```python
elif opcode == 10:  # sw
```
- Format: `opcode rs2, rs1, offset`
- Fields:
  - rs2: Source register (bits 16-23)
  - rs1: Base register (bits 8-15)
  - offset: Memory offset (bits 0-7)
- Operation: `memory[rs1 + offset] = rs2`

#### 4. B-Type Instructions
```python
elif opcode == 11:  # beq
elif opcode == 12:  # bne
elif opcode == 13:  # blt
```
- Format: `opcode rs1, rs2, offset`
- Fields:
  - rs1: First source register (bits 16-23)
  - rs2: Second source register (bits 8-15)
  - offset: Branch offset (bits 0-7)
- Operations:
  - beq: `if rs1 == rs2: pc += offset * 4`
  - bne: `if rs1 != rs2: pc += offset * 4`
  - blt: `if rs1 < rs2: pc += offset * 4`

#### 5. J-Type Instructions
```python
elif opcode == 14:  # jal
```
- Format: `opcode rd, imm`
- Fields:
  - rd: Destination register (bits 16-23)
  - imm: Jump offset (bits 0-15)
- Operation: `rd = pc + 4; pc += imm * 4`

#### 6. Special Instructions
```python
elif opcode == 15:  # rst
elif opcode == 16:  # halt
```
- rst: Resets all registers and memory
- halt: Stops program execution

## Program Loading

```python
def load_program(binary_file):
```
- Reads binary instruction file
- Converts each line to 32-bit integer
- Returns list of instructions

## Usage
```python
if __name__ == "__main__":
```
Command line usage:
```bash
python3 Simulator.py <binary_file>
```
- binary_file: File containing machine code instructions
- Each instruction should be a 32-bit hex number
- Program outputs execution trace and final memory state
