#!/usr/bin/env python3
"""
RISC-V Simulator Implementation

A clean and modular implementation of a RISC-V simulator that executes machine code
generated by the assembler. Features include:
- Register file simulation (32 registers)
- Data memory management (128 bytes)
- Stack memory support (128 bytes, grows downward)
- Instruction execution tracing
- Rich error handling and state reporting

Example Usage:
    python simulator.py program.bin

The simulator reads binary instructions and executes them while maintaining system
state (registers, memory, etc.) and providing detailed execution traces.
"""

import sys
from typing import List, Dict, Tuple
from dataclasses import dataclass

# Memory layout constants
MEM_SIZE = 32  # 32 words (128 bytes)
NUM_REGS = 32

# Instruction opcodes
OPCODES = {
    'add': 1, 'sub': 2, 'slt': 3, 'srl': 4,
    'or': 5, 'and': 6, 'lw': 7, 'addi': 8,
    'jalr': 9, 'sw': 10, 'beq': 11, 'bne': 12,
    'blt': 13, 'jal': 14, 'rst': 15, 'halt': 16
}

@dataclass
class ExecutionResult:
    """Holds the result of instruction execution."""
    next_pc: int
    opcode_name: str
    error: str = ''

class SimulationError(Exception):
    """Custom exception for simulation errors."""
    def __init__(self, message: str, pc: int):
        self.message = message
        self.pc = pc
        super().__init__(f"PC 0x{pc:08x}: {message}")

class Simulator:
    """RISC-V instruction set simulator."""
    
    def __init__(self, program: List[int]):
        """
        Initialize simulator state.
        
        Args:
            program: List of 32-bit instructions to execute
        """
        self.program = program
        self.registers = [0] * NUM_REGS
        self.data_memory = [0] * MEM_SIZE
        self.stack_memory = [0] * MEM_SIZE
        self.pc = 0
        self.halted = False

    def _sign_extend(self, value: int, bits: int) -> int:
        """Sign-extend a value to 32 bits."""
        sign_bit = 1 << (bits - 1)
        return (value & (sign_bit - 1)) - (value & sign_bit)

    def _check_memory_access(self, addr: int) -> None:
        """Validate memory access address."""
        if addr < 0 or addr >= MEM_SIZE:
            raise SimulationError(f"Memory access out of bounds: {addr}", self.pc)

    def _execute_r_type(self, instr: int) -> ExecutionResult:
        """Execute R-type arithmetic instructions."""
        rd = (instr >> 16) & 0xFF
        rs1 = (instr >> 8) & 0xFF
        rs2 = instr & 0xFF
        opcode = (instr >> 24) & 0xFF

        if rd == 0:  # x0 is hardwired to 0
            return ExecutionResult(self.pc + 4, "r-type-nop")

        val1 = self.registers[rs1]
        val2 = self.registers[rs2]

        operations = {
            OPCODES['add']: (lambda a, b: a + b, 'add'),
            OPCODES['sub']: (lambda a, b: a - b, 'sub'),
            OPCODES['slt']: (lambda a, b: 1 if a < b else 0, 'slt'),
            OPCODES['srl']: (lambda a, b: (a % 0x100000000) >> b, 'srl'),
            OPCODES['or']: (lambda a, b: a | b, 'or'),
            OPCODES['and']: (lambda a, b: a & b, 'and')
        }

        if opcode not in operations:
            raise SimulationError(f"Invalid R-type opcode: {opcode}", self.pc)

        operation, name = operations[opcode]
        self.registers[rd] = operation(val1, val2)
        return ExecutionResult(self.pc + 4, name)

    def _execute_i_type(self, instr: int) -> ExecutionResult:
        """Execute I-type load and immediate instructions."""
        rd = (instr >> 16) & 0xFF
        rs1 = (instr >> 8) & 0xFF
        imm = self._sign_extend(instr & 0xFF, 8)
        opcode = (instr >> 24) & 0xFF

        if rd == 0:  # x0 is hardwired to 0
            return ExecutionResult(self.pc + 4, "i-type-nop")

        if opcode == OPCODES['lw']:
            addr = self.registers[rs1] + imm
            self._check_memory_access(addr)
            self.registers[rd] = self.data_memory[addr]
            return ExecutionResult(self.pc + 4, 'lw')
            
        elif opcode == OPCODES['addi']:
            self.registers[rd] = self.registers[rs1] + imm
            return ExecutionResult(self.pc + 4, 'addi')
            
        elif opcode == OPCODES['jalr']:
            temp = self.pc + 4
            next_pc = self.registers[rs1] + imm
            self.registers[rd] = temp
            return ExecutionResult(next_pc, 'jalr')
            
        raise SimulationError(f"Invalid I-type opcode: {opcode}", self.pc)

    def _execute_s_type(self, instr: int) -> ExecutionResult:
        """Execute S-type store instructions."""
        rs2 = (instr >> 16) & 0xFF
        rs1 = (instr >> 8) & 0xFF
        offset = self._sign_extend(instr & 0xFF, 8)
        
        addr = self.registers[rs1] + offset
        self._check_memory_access(addr)
        self.data_memory[addr] = self.registers[rs2]
        return ExecutionResult(self.pc + 4, 'sw')

    def _execute_b_type(self, instr: int) -> ExecutionResult:
        """Execute B-type branch instructions."""
        rs1 = (instr >> 16) & 0xFF
        rs2 = (instr >> 8) & 0xFF
        offset = self._sign_extend(instr & 0xFF, 8)
        opcode = (instr >> 24) & 0xFF

        val1 = self.registers[rs1]
        val2 = self.registers[rs2]

        conditions = {
            OPCODES['beq']: (lambda a, b: a == b, 'beq'),
            OPCODES['bne']: (lambda a, b: a != b, 'bne'),
            OPCODES['blt']: (lambda a, b: a < b, 'blt')
        }

        if opcode not in conditions:
            raise SimulationError(f"Invalid B-type opcode: {opcode}", self.pc)

        condition, name = conditions[opcode]
        next_pc = self.pc + 4 + (offset * 4 if condition(val1, val2) else 0)
        return ExecutionResult(next_pc, name)

    def _execute_j_type(self, instr: int) -> ExecutionResult:
        """Execute J-type jump instructions."""
        rd = (instr >> 16) & 0xFF
        imm = self._sign_extend(instr & 0xFFFF, 16)
        
        if rd != 0:  # Only write to rd if it's not x0
            self.registers[rd] = self.pc + 4
            
        return ExecutionResult(self.pc + 4 + imm * 4, 'jal')

    def _print_state(self, instr: int, opcode_name: str) -> None:
        """Print current machine state."""
        print(f"\nPC: 0x{self.pc:08x}")
        print(f"Executed: {opcode_name} (0x{instr:08x})")
        
        print("\nRegisters:")
        for i in range(0, NUM_REGS, 8):
            regs = [f"x{j}:{self.registers[j]:4}" for j in range(i, i+8)]
            print(" ".join(regs))
            
        print("\nData Memory:")
        for i in range(0, MEM_SIZE, 8):
            mem = [f"[{j:02x}]:{self.data_memory[j]:4}" for j in range(i, i+8)]
            print(" ".join(mem))
            
        print("\n" + "-"*60)

    def run(self) -> None:
        """Execute the loaded program."""
        try:
            while self.pc < len(self.program)*4 and not self.halted:
                instr = self.program[self.pc // 4]
                opcode = (instr >> 24) & 0xFF

                # Execute instruction based on type
                try:
                    if opcode in range(1, 7):  # R-type
                        result = self._execute_r_type(instr)
                    elif opcode in range(7, 10):  # I-type
                        result = self._execute_i_type(instr)
                    elif opcode == 10:  # S-type
                        result = self._execute_s_type(instr)
                    elif opcode in range(11, 14):  # B-type
                        result = self._execute_b_type(instr)
                    elif opcode == 14:  # J-type
                        result = self._execute_j_type(instr)
                    elif opcode == 15:  # rst
                        self.registers = [0] * NUM_REGS
                        self.data_memory = [0] * MEM_SIZE
                        self.stack_memory = [0] * MEM_SIZE
                        result = ExecutionResult(self.pc + 4, 'rst')
                    elif opcode == 16:  # halt
                        self.halted = True
                        result = ExecutionResult(self.pc + 4, 'halt')
                    else:
                        raise SimulationError(f"Unknown opcode: {opcode}", self.pc)

                    self._print_state(instr, result.opcode_name)
                    self.pc = result.next_pc

                except SimulationError as e:
                    print(f"Error: {str(e)}")
                    self.halted = True
                    break

            print("\nFinal Data Memory State:")
            print(self.data_memory)
            print("\nSimulation " + ("halted." if self.halted else "completed."))

        except Exception as e:
            print(f"Fatal error: {str(e)}")
            sys.exit(1)

def load_program(binary_file: str) -> List[int]:
    """Load binary program from file."""
    try:
        program = []
        with open(binary_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line:
                    program.append(int(line, 2))  # Parse binary string
        return program
    except FileNotFoundError:
        print(f"Error: Could not open file {binary_file}")
        sys.exit(1)
    except ValueError:
        print("Error: Invalid instruction format in binary file")
        sys.exit(1)

def main():
    """Main entry point."""
    if len(sys.argv) != 2:
        print("Usage: python simulator.py <binary_file>")
        sys.exit(1)

    program = load_program(sys.argv[1])
    simulator = Simulator(program)
    simulator.run()

if __name__ == "__main__":
    main()
