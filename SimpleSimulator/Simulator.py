#!/usr/bin/env python3
"""
SimpleSimulator/Simulator.py

This script implements a simulator for a subset of the RV32I instruction set.
It reads a binary file (generated by the assembler) containing 32-bit hex instruction codes,
decodes and executes them, and prints the execution trace including register and memory state.

Supported Instructions:
  R-Type: add, sub, slt, srl, or, and
  I-Type: lw, addi, jalr
  S-Type: sw
  B-Type: beq, bne, blt
  J-Type: jal
  Bonus: rst, halt

Memory Layout:
  Program Memory: 256 bytes (64 locations)
  Data Memory: 128 bytes (32 locations)
  Stack Memory: 128 bytes (32 locations; grows downward)

Usage:
  python3 Simulator.py <binary_file>
"""

import sys

class Simulator:
    def __init__(self, program):
        self.program = program  # List of 32-bit integer instructions.
        self.registers = [0] * 32
        self.pc = 0
        self.data_memory = [0] * 32  # 128 bytes / 4 bytes per word.
        self.stack_memory = [0] * 32  # 128 bytes / 4 bytes per word.
        self.halted = False

    def sign_extend(self, value, bits):
        sign_bit = 1 << (bits - 1)
        return (value & (sign_bit - 1)) - (value & sign_bit)

    def print_state(self, instr, opcode_name):
        print(f"PC: {self.pc}")
        print(f"Executed: {opcode_name} -> 0x{instr:08x}")
        print("Registers:")
        for i in range(0, 32, 8):
            print(" ".join(f"x{j:02}:{self.registers[j]:>5}" for j in range(i, i+8)))
        print("Data Memory:")
        for i in range(0, 32, 8):
            print(" ".join(f"[{j:02}]:{self.data_memory[j]:>5}" for j in range(i, i+8)))
        print("-" * 50)

    def run(self):
        while self.pc < len(self.program)*4 and not self.halted:
            instr = self.program[self.pc // 4]
            opcode = (instr >> 24) & 0xFF
            
            # Save current PC to update if instruction does not branch or jump
            next_pc = self.pc + 4

            # Decode and execute based on opcode.
            if opcode == 1:  # add: R-type
                rd = (instr >> 16) & 0xFF
                rs1 = (instr >> 8) & 0xFF
                rs2 = instr & 0xFF
                self.registers[rd] = self.registers[rs1] + self.registers[rs2]
                opcode_name = "add"
            elif opcode == 2:  # sub
                rd = (instr >> 16) & 0xFF
                rs1 = (instr >> 8) & 0xFF
                rs2 = instr & 0xFF
                self.registers[rd] = self.registers[rs1] - self.registers[rs2]
                opcode_name = "sub"
            elif opcode == 3:  # slt
                rd = (instr >> 16) & 0xFF
                rs1 = (instr >> 8) & 0xFF
                rs2 = instr & 0xFF
                self.registers[rd] = 1 if self.registers[rs1] < self.registers[rs2] else 0
                opcode_name = "slt"
            elif opcode == 4:  # srl
                rd = (instr >> 16) & 0xFF
                rs1 = (instr >> 8) & 0xFF
                rs2 = instr & 0xFF
                self.registers[rd] = (self.registers[rs1] % 0x100000000) >> self.registers[rs2]
                opcode_name = "srl"
            elif opcode == 5:  # or
                rd = (instr >> 16) & 0xFF
                rs1 = (instr >> 8) & 0xFF
                rs2 = instr & 0xFF
                self.registers[rd] = self.registers[rs1] | self.registers[rs2]
                opcode_name = "or"
            elif opcode == 6:  # and
                rd = (instr >> 16) & 0xFF
                rs1 = (instr >> 8) & 0xFF
                rs2 = instr & 0xFF
                self.registers[rd] = self.registers[rs1] & self.registers[rs2]
                opcode_name = "and"
            elif opcode == 7:  # lw (I-type)
                rd = (instr >> 16) & 0xFF
                rs1 = (instr >> 8) & 0xFF
                offset = instr & 0xFF
                addr = self.registers[rs1] + self.sign_extend(offset, 8)
                if addr < 0 or addr >= len(self.data_memory):
                    print(f"Memory access error at address {addr}")
                    self.halted = True
                    opcode_name = "lw (error)"
                else:
                    self.registers[rd] = self.data_memory[addr]
                    opcode_name = "lw"
            elif opcode == 8:  # addi (I-type)
                rd = (instr >> 16) & 0xFF
                rs1 = (instr >> 8) & 0xFF
                imm = self.sign_extend(instr & 0xFF, 8)
                self.registers[rd] = self.registers[rs1] + imm
                opcode_name = "addi"
            elif opcode == 9:  # jalr (I-type)
                rd = (instr >> 16) & 0xFF
                rs1 = (instr >> 8) & 0xFF
                imm = self.sign_extend(instr & 0xFF, 8)
                temp = next_pc
                self.pc = self.registers[rs1] + imm
                self.registers[rd] = temp
                opcode_name = "jalr"
                self.print_state(instr, opcode_name)
                continue  # Skip normal pc update.
            elif opcode == 10:  # sw (S-type)
                rs2 = (instr >> 16) & 0xFF
                rs1 = (instr >> 8) & 0xFF
                offset = self.sign_extend(instr & 0xFF, 8)
                addr = self.registers[rs1] + offset
                if addr < 0 or addr >= len(self.data_memory):
                    print(f"Memory access error at address {addr}")
                    self.halted = True
                    opcode_name = "sw (error)"
                else:
                    self.data_memory[addr] = self.registers[rs2]
                    opcode_name = "sw"
            elif opcode == 11:  # beq (B-type)
                rs1 = (instr >> 16) & 0xFF
                rs2 = (instr >> 8) & 0xFF
                offset = self.sign_extend(instr & 0xFF, 8)
                if self.registers[rs1] == self.registers[rs2]:
                    next_pc = self.pc + 4 + offset * 4
                opcode_name = "beq"
            elif opcode == 12:  # bne (B-type)
                rs1 = (instr >> 16) & 0xFF
                rs2 = (instr >> 8) & 0xFF
                offset = self.sign_extend(instr & 0xFF, 8)
                if self.registers[rs1] != self.registers[rs2]:
                    next_pc = self.pc + 4 + offset * 4
                opcode_name = "bne"
            elif opcode == 13:  # blt (B-type)
                rs1 = (instr >> 16) & 0xFF
                rs2 = (instr >> 8) & 0xFF
                offset = self.sign_extend(instr & 0xFF, 8)
                if self.registers[rs1] < self.registers[rs2]:
                    next_pc = self.pc + 4 + offset * 4
                opcode_name = "blt"
            elif opcode == 14:  # jal (J-type)
                rd = (instr >> 16) & 0xFF
                imm = self.sign_extend(instr & 0xFFFF, 16)
                self.registers[rd] = next_pc
                next_pc = self.pc + 4 + imm * 4
                opcode_name = "jal"
            elif opcode == 15:  # rst (Bonus) - Reset registers and memories
                self.registers = [0] * 32
                self.data_memory = [0] * 32
                self.stack_memory = [0] * 32
                opcode_name = "rst"
            elif opcode == 16:  # halt
                opcode_name = "halt"
                self.halted = True
            else:
                print(f"Unknown opcode {opcode} at PC {self.pc}")
                self.halted = True
                opcode_name = "unknown"
            
            self.pc = next_pc
            self.print_state(instr, opcode_name)
        
        print("Final Data Memory State:")
        print(self.data_memory)
        print("Simulation halted.")

def load_program(binary_file):
    program = []
    with open(binary_file, 'r') as f:
        for line in f:
            line = line.strip()
            if line:
                program.append(int(line, 16))
    return program

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 Simulator.py <binary_file>")
        sys.exit(1)
    prog = load_program(sys.argv[1])
    sim = Simulator(prog)
    sim.run()
